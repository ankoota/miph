Von Neumann architecture and ASM (en)
===

Theory
---

 + Что же такое компьютер? Этимология. Машина Тьюринга. Что такое программа и алгоритм. При чём тут электроника? 
 + Вскользь, реально существующие вещи. Компьютер интересен как средство управления переферийными устройтвами. Электричество, напряжение в точке, полупроводниковые устройства, микроэлектроника. 
 + Данные и их представление. 2's complement. Floating point. Картинки. Регистры & перефирийные устройства.
 + Архитектура микропроцессора. Алу. Микропроцессор в действии. Логические операции.
 + Инструкции. CISC, RISC, Гарвард, фон Нейман.
 + Переферийные устройства, поллинг и прерывания
 + Ассемблер
 + Высокоуровневые языки програмирования.

Here we talk about how (most of modern) computers work, covering Von Neumann architecture
and how does it realate to ASM. @avelenko

Practice
---

 + Git basics @manpages
 + ASM basics @avelenko

Dark Side
---

"You don't have to code like this". 

![Von Neumann's architecture isn't about software][fortran77wat]

*(Image is taken from the beginners guide to Fortran77)*

Von Neumann's architecture isn't about software.
Lecture plan: 
  
 + When it fails (Concurrent world)
  - Пример с вечеринкой, где чтобы говорить нужно держать в руках бутылку кефира. Иллюстрация того, что в мире большинство вещей происходит параллельно.
  - Нас не пугает параллелизм реального мира. В онтологию "помещается" идея параллелизма.
  - Мир не устроен как %слайд из книги про Fortran77%! И если мы хотим создавать информационные системы, обслуживающие реальность, а не компьютеры, то удобнее всего будет воспользоваться инструментарием отличным от низкоуровневых языков программирования ЭВМ.
 + Why it fails (Shared memory, low level of abstractions, low expressiveness)
  - Пусть два процесса (тут имеется в виду абстрактный процесс, не процесс в понятийной базе Операционных Систем) хотят совершить некоторое действие над некоторым ресурсом. Они должны либо делить этот ресурс, либо получить по копии ресурса и сделать с ним что-то. Первый подход — общая память, второй подход — копирование при изменении. Плюсы, минусы. Применимость CoC к проблемам параллелизма.
  - От ASM перешли к более высокоуровневым языкам программирования, поскольку требовался (не-)определенный набор кирпичиков, которые бы помогали вне зависимости от платформы думать над проблемой и почти точно записывать ход своих мыслей в программный код. Если перед нами стоит проблема параллелизма, мы думаем о ней иначе (например в случае вечеринки, мы представляем себе людей, каждый из которых занимается чем-то своим и при этом обменивается сообщениями с другими людьми посредством рта), а соответственно, мы хотим, чтобы наш язык программирования давал нам те абстракции, которые нам необходимы для почти точной записи хода наших мыслей о параллельных системах.
  - Программный код настолько хорош, насколько читаем. Часто нам хочется написать что-то ёмкое вместо того, чтобы растекаться мыслью по древу (или по графу). В таких случаях хорошо, когда язык программирования предлагает способы, как записать какую-то идею достаточно коротко. Проблема тут в том, что если программист не понимает того, что происходит на низком уровне при написании ёмкого кода, он может потерять в эффективности во время исполнения или — чего хуже — получить ошибку, которую очень трудно найти. Пример из школьной жизни — теорема, которая требует остроты угла используется на тупой угол.
 + How it can be solved (Welcome to the world of declarative programming)
  - Подводим итоги — декларативные языки не делятся памятью, имеют высокую предсказуемость в работе, имеют высокий уровень абстракций и код на них ёмок.

Архитектура Фон Неймана и ассамблер (ru)
===

TODO


[fortran77wat]: http://www.idris.fr/data/cours/lang/fortran/f90/F77_repert/f77_1.gif
